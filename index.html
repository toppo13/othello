<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ã‚ªã‚»ãƒ­</title>
  <style>
    body {
      text-align: center;
      font-family: sans-serif;
      margin: 20px;
    }
    canvas {
      background-color: #3CB371;
      border: 4px solid #333;
      border-radius: 10px;
      touch-action: manipulation;
      display: none;
      max-width: 90vw;
      height: auto;
      margin: 0 auto;
    }
    #info, #message {
      margin-top: 10px;
      font-size: 18px;
    }
    #message {
      color: red;
      height: 24px;
    }
    #startScreen, #restartBtn {
      margin-top: 20px;
    }
    button {
      font-size: 20px;
      padding: 10px 20px;
      cursor: pointer;
    }
    select {
      font-size: 18px;
      margin-left: 10px;
      padding: 5px;
    }
  </style>
</head>
<body>
  <h1>ã‚ªã‚»ãƒ­</h1>
  <div id="startScreen">
    ãƒ¢ãƒ¼ãƒ‰ã‚’é¸æŠï¼š
    <select id="cpuLevelSelect">
      <option value="0">å¯¾äººæˆ¦</option>
      <option value="1">CPU(ãƒ¬ãƒ™ãƒ«1)</option>
      <option value="2">CPU(ãƒ¬ãƒ™ãƒ«2)</option>
      <option value="3">CPU(ãƒ¬ãƒ™ãƒ«3)</option>
      <option value="4">CPU(ãƒ¬ãƒ™ãƒ«4)</option>
    </select>
    <br><br>
    <button id="startBtn">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
  </div>
  <canvas id="board"></canvas>
  <div id="info"></div>
  <div id="message"></div>
  <div>
    <button id="restartBtn" style="display:none;">ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
  </div>

<script>
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");
const size = 8;
let cell;
let board;
let current;
let lastCpuMove;
const directions = [
  [-1, 0], [1, 0], [0, -1], [0, 1],
  [-1, -1], [-1, 1], [1, -1], [1, 1]
];

const infoDiv = document.getElementById("info");
const messageDiv = document.getElementById("message");
const startScreen = document.getElementById("startScreen");
const startBtn = document.getElementById("startBtn");
const restartBtn = document.getElementById("restartBtn");
const cpuLevelSelect = document.getElementById("cpuLevelSelect");

let cpuLevel = 0; // 0=å¯¾äººæˆ¦, 1-4 CPUãƒ¬ãƒ™ãƒ«

function resizeCanvas() {
  const minSize = Math.min(window.innerWidth * 0.9, 400);
  canvas.width = minSize;
  canvas.height = minSize;
  cell = canvas.width / size;
}
window.addEventListener("resize", () => {
  if (canvas.style.display === "block") {
    resizeCanvas();
    drawBoard();
  }
});

function initGame() {
  resizeCanvas();
  board = Array.from({ length: size }, () => Array(size).fill(0));
  board[3][3] = -1;
  board[4][4] = -1;
  board[3][4] = 1;
  board[4][3] = 1;
  current = 1; // é»’ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ
  lastCpuMove = null;
  messageDiv.textContent = "";
  infoDiv.textContent = cpuLevel === 0
    ? "é»’ã®ç•ªã§ã™ï¼ˆå¯¾äººæˆ¦ï¼‰"
    : "é»’ã®ç•ªã§ã™ï¼ˆCPUãƒ¬ãƒ™ãƒ«" + cpuLevel + "ï¼‰";
  drawBoard();

  // CPUãŒé»’ï¼ˆcurrent===1ï¼‰ã§å‹•ãè¨­å®šã‚‚è€ƒæ…®ï¼ˆä»Šã¯CPUã¯ç™½å´ã®ã¿æƒ³å®šï¼‰
  if (cpuLevel !== 0 && current === -1) {
    setTimeout(cpuMove, 500);
  }
}

function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "#000";
  for (let i = 0; i <= size; i++) {
    ctx.beginPath();
    ctx.moveTo(i * cell, 0);
    ctx.lineTo(i * cell, canvas.height);
    ctx.moveTo(0, i * cell);
    ctx.lineTo(canvas.width, i * cell);
    ctx.stroke();
  }
  if (lastCpuMove) {
    ctx.fillStyle = "rgba(255, 0, 0, 0.3)";
    ctx.fillRect(lastCpuMove[0] * cell, lastCpuMove[1] * cell, cell, cell);
  }
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      if (board[y][x] !== 0) {
        ctx.beginPath();
        ctx.arc(x * cell + cell / 2, y * cell + cell / 2, cell * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = board[y][x] === 1 ? "black" : "white";
        ctx.fill();
        ctx.stroke();
      }
    }
  }
  // æœ‰åŠ¹æ‰‹ã®è¡¨ç¤ºã¯äººé–“ã®ç•ªã®å ´åˆã®ã¿
  if ((current === 1) || (current === -1 && cpuLevel === 0)) {
    let moves = getValidMoves(current);
    for (const [x, y] of moves) {
      ctx.beginPath();
      ctx.arc(x * cell + cell / 2, y * cell + cell / 2, cell * 0.15, 0, Math.PI * 2);
      ctx.fillStyle = "yellow";
      ctx.fill();
    }
  }
}

function validMove(x, y, color) {
  if (board[y][x] !== 0) return false;
  for (const [dx, dy] of directions) {
    let nx = x + dx, ny = y + dy, flipped = 0;
    while (board[ny]?.[nx] === -color) {
      nx += dx; ny += dy; flipped++;
    }
    if (flipped > 0 && board[ny]?.[nx] === color) return true;
  }
  return false;
}

function flip(x, y, color) {
  for (const [dx, dy] of directions) {
    let nx = x + dx, ny = y + dy, path = [];
    while (board[ny]?.[nx] === -color) {
      path.push([nx, ny]);
      nx += dx; ny += dy;
    }
    if (path.length > 0 && board[ny]?.[nx] === color) {
      for (const [fx, fy] of path) {
        board[fy][fx] = color;
      }
    }
  }
}

function flipOnBoard(boardState, x, y, color) {
  for (const [dx, dy] of directions) {
    let nx = x + dx, ny = y + dy, path = [];
    while (boardState[ny]?.[nx] === -color) {
      path.push([nx, ny]);
      nx += dx; ny += dy;
    }
    if (path.length > 0 && boardState[ny]?.[nx] === color) {
      for (const [fx, fy] of path) {
        boardState[fy][fx] = color;
      }
    }
  }
}

function getValidMoves(color, b = board) {
  let moves = [];
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      if (b[y][x] !== 0) continue;
      for (const [dx, dy] of directions) {
        let nx = x + dx, ny = y + dy, flipped = 0;
        while (b[ny]?.[nx] === -color) {
          nx += dx; ny += dy; flipped++;
        }
        if (flipped > 0 && b[ny]?.[nx] === color) {
          moves.push([x, y]);
          break;
        }
      }
    }
  }
  return moves;
}

function hasValidMove(color) {
  return getValidMoves(color).length > 0;
}

function switchTurn() {
  current = -current;
  messageDiv.textContent = "";

  if (!hasValidMove(current)) {
    current = -current;
    if (!hasValidMove(current)) return endGame();
    messageDiv.textContent = "ãƒ‘ã‚¹ã—ã¾ã—ãŸã€‚";
  }

  infoDiv.textContent = current === 1
    ? "é»’ã®ç•ªã§ã™" + (cpuLevel === 0 ? "ï¼ˆå¯¾äººæˆ¦ï¼‰" : "ï¼ˆCPUãƒ¬ãƒ™ãƒ«" + cpuLevel + "ï¼‰")
    : "ç™½ã®ç•ªã§ã™" + (cpuLevel === 0 ? "ï¼ˆå¯¾äººæˆ¦ï¼‰" : "ï¼ˆCPUãƒ¬ãƒ™ãƒ«" + cpuLevel + "ï¼‰");

  drawBoard();

  if (cpuLevel !== 0 && current === -1) {
    setTimeout(cpuMove, 500);
  }
}

canvas.addEventListener("click", e => {
  // CPUã®ã‚¿ãƒ¼ãƒ³ã¯ã‚¯ãƒªãƒƒã‚¯ç¦æ­¢
  if (cpuLevel !== 0 && current === -1) return;

  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) / cell);
  const y = Math.floor((e.clientY - rect.top) / cell);
  if (!validMove(x, y, current)) {
    messageDiv.textContent = "ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚";
    return;
  }
  board[y][x] = current;
  flip(x, y, current);
  lastCpuMove = null;
  switchTurn();
  drawBoard();
});

function endGame() {
  const flat = board.flat();
  const black = flat.filter(c => c === 1).length;
  const white = flat.filter(c => c === -1).length;
  const result = black > white ? "é»’ã®å‹ã¡ï¼ğŸ‰" : white > black ? "ç™½ã®å‹ã¡ï¼ğŸ‰" : "å¼•ãåˆ†ã‘ï¼";
  infoDiv.textContent = `çµ‚äº†ï¼š${result} é»’${black} - ç™½${white}`;
  messageDiv.textContent = "";
  restartBtn.style.display = "inline-block";
}

// è©•ä¾¡é–¢æ•°ï¼ˆé§’å·®ï¼‹è§’å„ªå…ˆï¼‹è¾ºå„ªå…ˆï¼‰
const weights = [
  [120, -20, 20, 5, 5, 20, -20, 120],
  [-20, -40, -5, -5, -5, -5, -40, -20],
  [20, -5, 15, 3, 3, 15, -5, 20],
  [5, -5, 3, 3, 3, 3, -5, 5],
  [5, -5, 3, 3, 3, 3, -5, 5],
  [20, -5, 15, 3, 3, 15, -5, 20],
  [-20, -40, -5, -5, -5, -5, -40, -20],
  [120, -20, 20, 5, 5, 20, -20, 120]
];

function evaluate(boardState) {
  let score = 0;
  for (let y=0; y<size; y++) {
    for (let x=0; x<size; x++) {
      if (boardState[y][x] === -1) score += weights[y][x];
      else if (boardState[y][x] === 1) score -= weights[y][x];
    }
  }
  return score;
}

// CPUãƒ¬ãƒ™ãƒ«1: æœ€ã‚‚è©•ä¾¡å€¤ãŒä½ã„ï¼ˆè‡ªåˆ†ã«ã¨ã£ã¦æœ€æ‚ªã®ï¼‰æ‰‹ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶ï¼ˆå¿…ãšè² ã‘ã‚‹æ–¹å‘ï¼‰
function cpuMoveLevel1() {
  const moves = getValidMoves(-1);
  if (moves.length === 0) {
    switchTurn();
    return;
  }
  let worstScore = Infinity;
  let worstMoves = [];
  for (const [x, y] of moves) {
    let copy = board.map(r => [...r]);
    copy[y][x] = -1;
    flipOnBoard(copy, x, y, -1);
    let score = evaluate(copy);
    if (score < worstScore) {
      worstScore = score;
      worstMoves = [[x, y]];
    } else if (score === worstScore) {
      worstMoves.push([x, y]);
    }
  }
  const choice = worstMoves[Math.floor(Math.random() * worstMoves.length)];
  const [x, y] = choice;
  board[y][x] = -1;
  flip(x, y, -1);
  lastCpuMove = [x, y];
  switchTurn();
  drawBoard();
}

// CPUãƒ¬ãƒ™ãƒ«2: è©•ä¾¡é–¢æ•°ã§æœ€ã‚‚ã‚¹ã‚³ã‚¢ã®é«˜ã„æ‰‹ã‚’é¸ã¶
function cpuMoveLevel2() {
  const moves = getValidMoves(-1);
  if (moves.length === 0) {
    switchTurn();
    return;
  }
  let bestScore = -Infinity;
  let bestMove = null;
  for (const [x, y] of moves) {
    let copy = board.map(r => [...r]);
    copy[y][x] = -1;
    flipOnBoard(copy, x, y, -1);
    let score = evaluate(copy);
    if (score > bestScore) {
      bestScore = score;
      bestMove = [x, y];
    }
  }
  const [x, y] = bestMove;
  board[y][x] = -1;
  flip(x, y, -1);
  lastCpuMove = [x, y];
  switchTurn();
  drawBoard();
}

// CPUãƒ¬ãƒ™ãƒ«3: Minimaxæ·±ã•3, Î±Î²æåˆˆã‚Šä»˜ã
function minimax(boardState, depth, alpha, beta, maximizingPlayer) {
  if (depth === 0) return evaluate(boardState);
  const color = maximizingPlayer ? -1 : 1;
  const moves = getValidMoves(color, boardState);
  if (moves.length === 0) {
    // ãƒ‘ã‚¹å‡¦ç†
    const oppMoves = getValidMoves(-color, boardState);
    if (oppMoves.length === 0) return evaluate(boardState); // çµ‚äº†å±€é¢
    return minimax(boardState, depth - 1, alpha, beta, !maximizingPlayer);
  }
  if (maximizingPlayer) {
    let maxEval = -Infinity;
    for (const [x, y] of moves) {
      let copy = boardState.map(r => [...r]);
      copy[y][x] = color;
      flipOnBoard(copy, x, y, color);
      let evalScore = minimax(copy, depth - 1, alpha, beta, false);
      maxEval = Math.max(maxEval, evalScore);
      alpha = Math.max(alpha, evalScore);
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (const [x, y] of moves) {
      let copy = boardState.map(r => [...r]);
      copy[y][x] = color;
      flipOnBoard(copy, x, y, color);
      let evalScore = minimax(copy, depth - 1, alpha, beta, true);
      minEval = Math.min(minEval, evalScore);
      beta = Math.min(beta, evalScore);
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

function cpuMoveLevel3() {
  const moves = getValidMoves(-1);
  if (moves.length === 0) {
    switchTurn();
    return;
  }
  let bestScore = -Infinity;
  let bestMove = null;
  for (const [x, y] of moves) {
    let copy = board.map(r => [...r]);
    copy[y][x] = -1;
    flipOnBoard(copy, x, y, -1);
    let score = minimax(copy, 3, -Infinity, Infinity, false);
    if (score > bestScore) {
      bestScore = score;
      bestMove = [x, y];
    }
  }
  const [x, y] = bestMove;
  board[y][x] = -1;
  flip(x, y, -1);
  lastCpuMove = [x, y];
  switchTurn();
  drawBoard();
}

// CPUãƒ¬ãƒ™ãƒ«4: Minimaxæ·±ã•4, Î±Î²æåˆˆã‚Šä»˜ã
function cpuMoveLevel4() {
  const moves = getValidMoves(-1);
  if (moves.length === 0) {
    switchTurn();
    return;
  }
  let bestScore = -Infinity;
  let bestMove = null;
  for (const [x, y] of moves) {
    let copy = board.map(r => [...r]);
    copy[y][x] = -1;
    flipOnBoard(copy, x, y, -1);
    let score = minimax(copy, 4, -Infinity, Infinity, false);
    if (score > bestScore) {
      bestScore = score;
      bestMove = [x, y];
    }
  }
  const [x, y] = bestMove;
  board[y][x] = -1;
  flip(x, y, -1);
  lastCpuMove = [x, y];
  switchTurn();
  drawBoard();
}

function cpuMove() {
  switch(cpuLevel) {
    case 1: cpuMoveLevel1(); break;
    case 2: cpuMoveLevel2(); break;
    case 3: cpuMoveLevel3(); break;
    case 4: cpuMoveLevel4(); break;
    default: break;
  }
}

startBtn.addEventListener("click", () => {
  cpuLevel = parseInt(cpuLevelSelect.value, 10);
  startScreen.style.display = "none";
  canvas.style.display = "block";
  restartBtn.style.display = "none";
  initGame();
});

restartBtn.addEventListener("click", () => {
  restartBtn.style.display = "none";
  initGame();
});

</script>
</body>
</html>
